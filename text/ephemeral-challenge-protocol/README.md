# HIPE XXXX: Ephemeral Challenge protocol
- Authors: Tobias Looker <tplooker@gmail.com>
- Start Date: 2018-02-23
- PR:

## Summary
[summary]: #summary

Explains an approach to a general purpose challenged based protocol for identity agents.

## Motivation
[motivation]: #motivation

We have standardised upon a connection protocol that establishes persisted connections and allows disclosure of mutually authentication information. However there are several use cases where persisted connections are not warranted or the interaction between two parties is signalled over a medium and a challenge must be issued that links back to a connection. In both cases this warrants an ephemeral approach, allowing for the generation of transient challenges. 

The protocol gathers its name in two parts.

"Ephemeral" - The protocol is largely about instantaneous interactions. Even though a challenge issued in this protocol could have a reliance on prior state such as the existence of a connection or a credential in the challenge responders wallet.

"Challenge" - The protocol is about arbitrarily challenging a party, whether that be to prove possession of a verifiable credential, or a key relating to a persisted connection. 

## Use Case Description

### Alice logging into her bank Faber (example using QR codes as out of band process)

Alice has become a customer of Faber, in the process of becoming a customer, Faber connected with her SSI wallet and created a persisted pairwise connection with her. During the setup of this connection, Faber also disclosed to Alice its public DID used to publicly identify the organization (`did:sov:abcdefg12345`) and Alice associated this DID to the pairwise connection she has with Faber.
1. Alice visits `www.faber-bank.com`.
2. Alice navigates to the login page of the Faber bank website and clicks the `Login with SSI` button.
3. A QR code appears with instructions for Alice to scan it using her mobile wallet.
4. Using her mobile wallet Alice scans the code and a prompt in the app appears saying `Verification required` with the information indicating that Faber Bank is requesting proof of connection.
5. Alice accepts this request on her mobile app and notices that the Faber bank website has updated and logged her into her account.

### Alice purchasing an age restricted product online (example using QR codes as out of band process)

Alice has reached checkout with an online retailer `Wine to go`, where she wishes to complete purchase for alcohol which is age restricted. Alice has already got a mobile wallet and has obtained a credential (such as a driver licence) from a trusted issuer. Alice has no prior connection with `wine-to-go`.

1. Alice visits `www.wine-to-go.com`.
2. On the checkout cart page of `www.wine-to-go.com`, Alice clicks the `Verify age with mobile wallet` button.
3. A QR code appears with instructions for Alice to scan it using her mobile wallet.
4. Using her mobile wallet Alice scans the code and a prompt in the app appears saying `Verification required` with the information indicating that `wine-to-go` is requesting proof of her age.
5. Alice accepts this request on her mobile app and notices that the `Wine to go` website has updated with a status indicating that her age has been verified. 

## Tutorial

Below describes the challenge protocol, defining the roles, states and messages required.

### Name and Version

This defines the `Ephemeral Challenge` protocol, version 1.x as defined by the following URI:

`did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/ephemeral_challenge/1.0`

### Key Concepts

This protocol defines the standardised way in which ephemeral challenges are defined and how they are processed and responded to.

### Roles

There are two primary roles involved in this protocol

`Challenger` - The challenger is the party responsible for generating the challenge and verifying the challenge response.

`Challenge Responder` - The challenge responder is the party responsible for accepting the challenge and generating a valid challenge response.

### States

#### Null

No challenge exists

#### Challenged

A challenge has been generated by the challenger and shared with a challenge responder

#### Challenge Accepted

A challenge has been accepted by a challenge responder and a valid challenge response has been generated and sent back to the challenger

### Messages

All messages in this protocol are part of the "ephemeral challenge 1.0" message family uniquely identified by this DID reference: `did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/ephemeral_challenge/1.0`

#### Challenge message

The protocol can begin when the challenger sends a challenge message to the would be challenge responder which has the following definition:

```
{
    "@type" : "did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/ephemeral_challenge/1.0/challenge",
    "@id" : "624f736c-bbb1-4236-945f-8a9feff012dd",
    "recipientKeys": ["8HH5gYEeNc3z7PYXmd54d4x6qAfCNrqQqEB3nS7Zfu7K"],
    "routingKeys": ["8HH5gYEeNc3z7PYXmd54d4x6qAfCNrqQqEB3nS7Zfu7K"]
    "serviceEndpoint": "https://example.com/endpoint",
    "challenge" : {
        "type" : "<challenge type>",
        "contents" : {
            //contents of the challenge
        }
    }
}
```

`@id` is required here, as it establishes a message thread and allows the `challenge response` to be correlated.

`recipientKeys` an array of base58 encoded keys to which the challenge response should be encrypted to using `anoncrypt`

`routingKeys` an array of base58 encoded keys to which the message should be wrapped for

`serviceEndpoint` the uri to which the resulting packed challenge response should be sent to

`challenge` the challenge, see the challenge types section for more information.

Note : It is important to note that how the challenge message is communicated to the challenger is out of band

#### Challenge Response message

If the recipient of the challenge chooses to accept, then they become the challenge responder and generate a challenge response that takes the below form.  

```
{
    "@type" : "did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/ephemeral_challenge/1.0/challenge_response",
    "@id" : "624f736c-bbb1-4236-945f-8a9feff012dd",
    "response" : {
        "type" : "<challenge type>",
        contents: {
            //Contents of the challenge response
        }
    }
}
```

`response` the contents of the challenge response, see the challenge types section for more information.

Notes 
- The challenge message acts as both the medium in which to communicate the challenge and also how to deliver the challenge response back.
- When preparing a challenge response the `recipientKeys` `routingKeys` and `serviceEndpoint` are used in combination to achieve a delivery path for the challenge response back to the challenger.
- When packing the message it should be `anoncrypted` to the `recipientKeys` featured in the challenge. 

### Challenge types

Below describes a list of different valid challenges

#### Indy Proof Request

An indy based proof request is when the challenger is asking for proof of certain credentials 

The challenge field in the challenge message takes the following form.

```
challenge : {
    "type" : "indy-proof"
    "content" : {
        //libindy based proof request
    }
}
```

The response field in the challenge response message takes the following form

```
"response" : {
    "type" : "indy-proof",
    contents: {
        //libindy proof
    }
}
```

#### Pairwise Connection Proof

A pairwise connection proof is when the challenger is asking for proof of a pairwise connection.

Background - Alice and Faber have prior established a pairwise connection where Faber has both a public did (`did:sov:123456abcdefg`) and a pairwise did (`did:peer:12aq4wx1e4x`) that Alice knows it by. Faber on the other hand has a pairwise did (`did:peer:1234561aruvnwiru`) it knows Alice by.

The challenge field in the challenge message takes the following form.

```
challenge : {
    "type" : "pairwise-proof"
    "content" : {
        "did" : "did:sov:123456abcdefg",
        "nounce" : "123456789"
    }
}
```

The above message is required to be signed as described in HIPE ???. The `content` attribute above will be base64URL encoded and included as part of the `sig_data` attribute of the signed field. The result looks like the following:

```
challenge : {
    "type" : "pairwise-proof"
    "content~sig" : {
        "@type":"did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/signature/1.0/ed25519Sha512_single",
        "signature": "<digital signature function output>",
        "sig_data": "<base64URL(64bit_integer_from_unix_epoch||connection_attribute)>",
        "signers": "<signing_verkey>"
    }
}
```

Where the `signing_verkey` must be a key described in authorization section of the resolved did doc for `did:sov:123456abcdefg` (i.e the challenger).

The response field in the challenge response message takes the following form.

```
"response" : {
    "type" : "pairwise-proof",
    "content" : {
        "pairwiseDid" : "did:peer:1234561aruvnwiru",
        "challengeNounce" : "123456789"
    }
}
```

The above message is required to be signed as described in HIPE ???. The `content` attribute above will be base64URL encoded and included as part of the `sig_data` attribute of the signed field. The result looks like the following:

```
challenge : {
    "type" : "pairwise-proof"
    "content~sig" : {
        "@type":"did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/signature/1.0/ed25519Sha512_single",
        "signature": "<digital signature function output>",
        "sig_data": "<base64URL(64bit_integer_from_unix_epoch||connection_attribute)>",
        "signers": "<signing_verkey>"
    }
}
```

Where the `signing_verkey` must be a key described in authorization section of the resolved did doc for `did:peer:1234561aruvnwiru` (i.e the challenge responder).

## Reference

## Unresolved questions

- In the absence of a standardized presentation protocol for non-indy based credentials the most appropriate immediate path would be to use a scoped challenge type that is specific to indy?


