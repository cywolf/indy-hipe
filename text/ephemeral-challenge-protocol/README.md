# HIPE XXXX: Ephemeral Challenge protocol
- Authors: Tobias Looker <tplooker@gmail.com>
- Start Date: 2018-02-23
- PR:

## Summary
[summary]: #summary

Explains an approach to a challenged based protocol for identity agents in the absence of persisted connections.

## Motivation
[motivation]: #motivation

We have standardised upon a connection protocol that establishes persisted connections and allows disclosure of verifiable information along them. However there are several use cases where persisted connections are not warrented and hence we need an ephemeral approach, allowing for transient challenges to occur. 

## Use Case Description

### Alice purchasing an age restricted product online (example using QR codes as out of band process)

Alice has reached checkout with an online retailer `wine-to-go`, where she wishes to complete purchase for alcohol which is age restricted. Alice has already got a mobile wallet and has obtained a credential (such as a driver licence) from a trusted issuer. Alice has no prior connection with `wine-to-go`.

1. On the checkout page of `wine-to-go`, Alice clicks the `Verify age with mobile wallet` button.
2. A QR code appears with instructions for Alice to scan it using her mobile wallet.
3. Using her mobile wallet Alice scans the code and a prompt in the app appears saying `Verification required` with the information indicating that `wine-to-go` is requesting proof of her age.
4. Alice accepts this request on her mobile app and notices that the `wine-to-go` website has updated with a status indicating that her age has been verified. 

## Tutorial

Below describes the challenge protocol, defining the roles, states and messages required.

### Name and Version

This defines the `Ephemeral Challenge` protocol, version 1.x as defined by the following URI:

`did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/ephemeral_challenge/1.0`

### Key Concepts

This protocol defines the standardised way in which ephemeral challenges are defined and how they are processed and responded to.

### Roles

There are two primary roles involved in this protocol

`Challenger` - The challenger is the party responsible for generating the challenge and verifying the challenge response.

`Challenge Responder` - The challenge responder is the party responsible for accepting the challenge and generating a valid challenge response.

### States

#### Null

No challenge exists

#### Challenged

A challenge has been generated by the challenger and shared with a challenge responder

#### Challenge Accepted

A challenge has been accepted by a challenge responder and a valid challenge response has been generated and sent back to the challenger

#### Challenge Denied

A challenge has been denied by a challenge responder by tramitting a response back to the challenger indicating the outcome

### Messages

All messages in this protocol are part of the "ephemeral challenge 1.0" message family uniquely identified by this DID reference: `did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/ephemeral_challenge/1.0`

#### Challenge message

The protocol can begin when the challenger sends a `challenge` message to the other party which looks like this:

```
{
    "@type" : "did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/ephemeral_challenge/1.0/challenge",
    "@id" : "624f736c-bbb1-4236-945f-8a9feff012dd",
    "recipientKeys": ["8HH5gYEeNc3z7PYXmd54d4x6qAfCNrqQqEB3nS7Zfu7K"],
    "routingKeys": ["8HH5gYEeNc3z7PYXmd54d4x6qAfCNrqQqEB3nS7Zfu7K"]
    "serviceEndpoint": "https://example.com/endpoint",
    "challenge" : {
        "type" : "<challenge type>",
        "contents" : {
            //contents of the challenge
        }
    }
}
```

`@id` is required here, as it establishes a message thread and allows the `challenge response` to be correlated.

`recipientKeys` an array of base58 encoded keys to which the challenge response should be encrypted to using `anoncrypt`

`routingKeys` an array of base58 encoded keys to which the message should be wrapped for

`serviceEndpoint` the uri to which the resulting packed challenge response should be sent to

`challenge` the challenge, see the challenge types section for more information.

Note : It is important to note that how the challenge message is communicated to the challenger in the absence of a persisted connection, is out of band

#### Challenge Response message

```
{
    "@type" : "did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/ephemeral_challenge/1.0/challenge_response",
    "@id" : "624f736c-bbb1-4236-945f-8a9feff012dd",
    "status" : "Accepted",
    "response" : {
        "type" : "<challenge type>",
        contents: {
            //Contents of the challenge response
        }
    }
}
```

`status` respresents the intent of the responding party, valid states of this field are `Accepted` and `Denied`

`response` the contents of the challenge response, see the challenge types section for more information.

### Challenge types

Below describes a list of different valid challenges

#### Indy proof request

An indy based proof request takes the following form

```
challenge : {
    "type" : "libindy-proof-request"
    "content" : {
        //libindy based proof request
    }
}
```

The response field in the `challenge_response` takes the following form

```
"response" : {
    "type" : "libindy-proof",
    contents: {
        //libindy proof
    }
}
```

#### Key possession proof

//TODO what if the challenge is simply asking the challenge responder to prove posession of a shared secret or private key?

## Reference

## Unresolved questions

- Key possession proof definition
